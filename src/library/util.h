/*
 * util.h - cve-check-tool
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#pragma once

#define _GNU_SOURCE

#include <glib.h>
#include <stdbool.h>
#include <gio/gio.h>
#include <string.h>
#include <libxml/xmlreader.h>
#include <libgen.h>
#include <sys/stat.h>
#include <limits.h>
#include <stdlib.h>

#include "cve-check-tool.h"
#include "cve-string.h"

#include "faux.h"

/**
 * Attempt to guess the package type from the path
 *
 * @param path Full path to file
 * @param recurse Allow recursion into the directory
 * @return The guessed package type (may be PACKAGE_TYPE_UNKNOWN)
 */
PackageType guess_package_type(gchar *path, bool recurse);

/**
 * Determine if a given file is actually a list of packages..
 */
bool is_package_list(char *path);


/**
 * Determine if a file is one the enumerator is interested in
 *
 * @note Paths are relative basename, not absolute
 */
typedef bool (*package_match_func)(const gchar*);

/**
 * Recursively replace macros within a string
 *
 * @note Original string will be free'd, only perform on allocated
 * strings!
 *
 * @param macros Populated macro table (key->value)
 * @param str String to perform replacement on
 *
 * @return newly allocated string after replacements are performed
 */
gchar *demacro(GHashTable *macros, gchar *str);


/**
 * Convert an XML formatted date into unix seconds
 *
 * @param date XML input
 * @return int64_t unix timestamp, or -1 if it doesn't parse
 */
int64_t parse_xml_date(const char *date);

/**
 * Search the repo source directory for all matching sources
 *
 * @param directory Base directory to recurse
 * @param match A function to determine "matching" source packages
 * @param recurse Whether we can recurse the given directory
 * @param cb A callback to execute when we encounter a matching package
 */
bool find_sources(const char *directory, package_match_func match, bool recurse, cve_add_callback cb);

/**
 * Implemented in a *similar* fashion to how g_autoptr is intended to
 * work in future, but without the concerns of MSVC, etc..
 */
#define DEF_AUTOFREE(N,C) \
        static inline void _autofree_func_##N (void *p) {\
                if (p && *(N**)p) { \
                        /* To debug: printf("Freeing %s\n", #N); */\
                        C (*(N**)p);\
                        (*(void**)p) = NULL;\
                } \
        }

#define autofree(N) __attribute__ ((cleanup( _autofree_func_##N ))) N

/**
 * Enable easier integration with autofree. Note this is still a single
 * pointer, you need to use it like: gstrv*, NOT gstrv.
 */
typedef gchar* gstrv;

/**
 * Autofree helper: Cleanup a GFileEnumerator
 *
 * @param enu A valid GFileEnumerator pointer
 */
static inline void cve_io_enum_close(GFileEnumerator *enu)
{
        if (!enu) {
                return;
        }
        g_file_enumerator_close(enu, NULL, NULL);
        g_object_unref(enu);
}

/**
 * We don't allow direct use, as this handles multiple GInputStream
 * subclasses.. */
static inline void cve_io_close(void *stream)
{
        if (!stream) {
                return;
        }
        g_input_stream_close(stream, NULL, NULL);
        g_object_unref(stream);
}
static inline void cve_io_close_out(void *stream)
{
        if (!stream) {
                return;
        }
        g_output_stream_close(stream, NULL, NULL);
        g_object_unref(stream);
}

/**
 * Load mapping to real product name from the given ini file
 *
 * @note product/vendor will be newly allocated strings
 *
 * @param product Where to store the product name
 * @param vendor Where to store the product vendor name
 * @return a boolean value, indicating success or failure
 */
bool load_cve_mapping(const char *path, char **product, char **vendor);

DEF_AUTOFREE(GDateTime, g_date_time_unref)
DEF_AUTOFREE(GOptionContext, g_option_context_free)
DEF_AUTOFREE(gchar, g_free)
DEF_AUTOFREE(GError, g_error_free)
DEF_AUTOFREE(gstrv, g_strfreev)
DEF_AUTOFREE(GFileEnumerator, cve_io_enum_close)
DEF_AUTOFREE(GFile, g_object_unref)
DEF_AUTOFREE(GFileInputStream, cve_io_close)
DEF_AUTOFREE(GFileOutputStream, cve_io_close_out)
DEF_AUTOFREE(GOutputStream, cve_io_close_out)
DEF_AUTOFREE(GDataInputStream, cve_io_close)
DEF_AUTOFREE(GHashTable, g_hash_table_unref)
DEF_AUTOFREE(GTimeZone, g_time_zone_unref)
DEF_AUTOFREE(GZlibDecompressor, g_object_unref)
DEF_AUTOFREE(GKeyFile, g_key_file_unref)
DEF_AUTOFREE(cve_string, cve_string_free)
DEF_AUTOFREE(CveDB, cve_db_free)

/**
 * Suger-utility: Determine if a string contains a certain word
 *
 * @param word String to check
 * @param needle "word" to search for
 *
 * @return a boolean value, true if the string contains the word
 */
static inline bool str_contains(const gchar *word, const gchar *needle)
{
        return strstr(word, needle) != NULL;
}

/**
 * Utility to replace one word with another in a string
 *
 * @note Only use on allocated strings, as this will free the original
 * string!
 *
 * @param source (Allocated) source string to perform replacement on
 * @param word Word to replace
 * @param replace Replacement word
 *
 * @return A newly allocated string with the replacement performed
 */
static inline gchar *str_replace(gchar *source, const gchar *word, const gchar *replace)
{
        autofree(gstrv) *splits = NULL;
        gchar *ret = NULL;
        splits = g_strsplit(source, word, -1);
        ret = g_strjoinv(replace, splits);
        g_free(source);
        return ret;
}

/**
 * Helper utility to free a struct source_package_t
 */
static inline void package_free(void *p)
{
        if (!p) {
                return;
        }
        struct source_package_t *t = p;
        struct FauxData *d = NULL;

        if (t->issues) { /* bless you */
                g_list_free_full(t->issues, xmlFree);
        }
        if (t->patched) {
                g_list_free_full(t->patched, xmlFree);
        }
        if (t->path) {
                free(t->path);
        }
        if (t->xml) {
                xmlFree((xmlChar*)t->name);
                xmlFree((xmlChar*)t->version);
        } else {
                g_free((gchar*)t->name);
                g_free((gchar*)t->version);
        }
        if (t->extra) {
                switch (t->type) {
                case PACKAGE_TYPE_SRPM:
                        g_strfreev(t->extra);
                        break;
                case PACKAGE_TYPE_RPM:
                        g_list_free_full(t->extra, g_free);
                        break;
                case PACKAGE_TYPE_FAUX:
                        d = t->extra;
                        if (d->patched) {
                                g_strfreev(d->patched);
                        }
                        if (d->ignored) {
                                g_strfreev(d->ignored);
                        }
                        free(d);
                default:
                        break;
                }
        }

        free(t);
}

static inline bool cve_file_exists(const char *p)
{
        struct stat st = {.st_ino = 0};
        return (stat(p,&st) == 0);
}

static inline bool cve_is_dir(const char *p)
{
        struct stat st = {.st_ino = 0};
        if (stat(p, &st) != 0) {
                return false;
        }
        return S_ISDIR(st.st_mode);
}

static inline char *cve_get_file_parent(const char *p)
{
        char *r = realpath(p, NULL);
        if (!r) {
                return NULL;
        }
        return dirname(r);
}
