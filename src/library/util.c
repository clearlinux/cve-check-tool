/*
 * util.c - cve-check-tool
 *
 * Copyright (C) 2015 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE
#include <glib.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <dirent.h>
#include <string.h>

#include "util.h"
#include "cve-check-tool.h"

#include "eopkg.h"
#include "rpm.h"
#include "pkgbuild.h"

#define streq(x,y) strcmp(x,y) == 0

DEF_AUTOFREE(char, free)

bool find_sources(const char *path, package_match_func match, bool recurse)
{
        struct stat st = {0};
        bool ret = false;
        DIR *dir = NULL;
        struct dirent *ent = NULL;
        char *fullp = NULL;

        if (!match) {
                return false;
        }

        if (lstat(path, &st) != 0) {
                goto end;
        }

        if (S_ISLNK(st.st_mode)) {
                ret = false;
                goto end;
        } else if (S_ISDIR(st.st_mode)) {
                if (!(dir = opendir(path))) {
                        goto end;
                }
                while ((ent = readdir(dir))) {
                        if (!streq(ent->d_name, ".") && !streq(ent->d_name, "..")) {
                                if (!asprintf(&fullp, "%s/%s", path, ent->d_name)) {
                                        goto end;
                                }
                                if (!(cve_is_dir(fullp) && !recurse)) {
                                        find_sources(fullp, match, recurse);
                                }
                                free(fullp);
                        }
                }
        } else if (S_ISREG(st.st_mode)) {
                if (match(path)) {
                        cve_add_package(path);
                }
        }

        ret = true;
end:
        if (dir) {
                closedir(dir);
        }
        return ret;
}

PackageType guess_package_type(gchar *path, bool recurse)
{
        DIR *dir = NULL;
        struct dirent *ent = NULL;
        PackageType type = PACKAGE_TYPE_UNKNOWN;
        struct stat st = {0}, stc = {0};
        char *p = realpath(path, NULL);

        if (!p) {
                return PACKAGE_TYPE_UNKNOWN;
        }

        if (stat(p, &st) != 0) {
                goto end;
        }
        if (S_ISREG(st.st_mode)) {
                if (eopkg_is_package(p)) {
                        type = PACKAGE_TYPE_EOPKG;
                } else if (rpm_is_package(p)) {
                        type = PACKAGE_TYPE_RPM;
                } else if (pkgbuild_is_package(p)) {
                        type = PACKAGE_TYPE_PKGBUILD;
                } else if (faux_is_package(p)) {
                        type = PACKAGE_TYPE_FAUX;
                }
                goto end;
        } else if (S_ISDIR(st.st_mode) && recurse) {
                if (!(dir = opendir(p))) {
                        goto end;
                }
                while ((ent = readdir(dir))) {
                        autofree(char) *cp = NULL;

                        if (streq(ent->d_name, ".") || streq(ent->d_name, "..")) {
                                continue;
                        }
                        if (!asprintf(&cp, "%s/%s", p, ent->d_name)) {
                                goto end;
                        }
                        if (stat(cp, &stc) != 0) {
                                continue;
                        }
                        if (!S_ISREG(stc.st_mode)) {
                                continue;
                        }

                        if (eopkg_is_package(cp)) {
                                type = PACKAGE_TYPE_EOPKG;
                                break;
                        } else if (rpm_is_package(cp)) {
                                type = PACKAGE_TYPE_RPM;
                                break;
                        } else if (pkgbuild_is_package(cp)) {
                                type = PACKAGE_TYPE_PKGBUILD;
                                break;
                        } else if (faux_is_package(cp)) {
                                type = PACKAGE_TYPE_FAUX;
                        }
                }
        }
end:
        if (dir) {
                closedir(dir);
        }
        if (p) {
                free(p);
        }
        return type;
}

bool is_package_list(char *path)
{
        if (g_str_has_suffix((gchar*)path, "packages") || g_str_has_suffix((gchar*)path, "packages-nvr")) {
                return g_file_test((gchar*)path, G_FILE_TEST_IS_REGULAR);
        }
        return false;
}


gchar *demacro(GHashTable *macros, gchar *str)
{
        gchar *key = NULL, *value = NULL;

        if (!macros) {
                return str;
        }

        while (true) {
                bool hit = false;
                GHashTableIter iter;
                g_hash_table_iter_init(&iter, macros);
                while (g_hash_table_iter_next(&iter, (void**)&key, (void**)&value)) {
                        if (str_contains(str, key)) {
                                hit = true;
                                str = str_replace(str, key, value);
                        }
                }
                if (!hit) {
                        break;
                }
        }
        return str;
}

int64_t parse_xml_date(const char *date)
{
        autofree(cve_string) *tmp = cve_string_dup(date);
        autofree(GTimeZone) *tz = NULL;
        autofree(GDateTime) *t = NULL, *t2 = NULL;
        char *c = NULL;
        int64_t ret = -1;

        /* Example XML string:
         * 2015-03-05T08:24:10.220-05:00
         */
        if (!tmp) {
                return -1;
        }
        if (!(c = memchr(tmp->str, 'T', tmp->len))) {
                return -1;
        }
        if (!(c = memchr(c, '-', tmp->len - (tmp->str -c)))) {
                return -1;
        }
        gint y, m, d, h, min, s;
        if (sscanf(date, "%4d-%2d-%2dT%2d:%2d:%2d", &y, &m, &d,
                &h, &min, &s) != 6) {
                return -1;
        }
        tz = g_time_zone_new(c);
        if (!tz) {
                return -1;
        }

        t = g_date_time_new(tz, y, m, d, h, min, (gdouble)s);
        if (!t) {
                return -1;
        }
        t2 = g_date_time_to_local(t);

        ret = (int64_t)g_date_time_to_unix(t2);

        return ret;
}

bool load_cve_mapping(const char *path, char **product, char **vendor)
{
        autofree(GFile) *fi = NULL;
        autofree(GFileInputStream) *fis = NULL;
        autofree(GDataInputStream) *dis = NULL;
        gsize size;
        gchar *line = NULL;
        gchar *kproduct = NULL;
        gchar *kvendor = NULL;

        fi = g_file_new_for_path(path);
        if (!fi) {
                return false;
        }
        fis = g_file_read(fi, NULL, NULL);
        if (!fis) {
                return false;
        }
        dis = g_data_input_stream_new(G_INPUT_STREAM(fis));

        while ((line = g_data_input_stream_read_line(dis, &size, NULL, NULL))) {
                char *c = NULL;
                char *val = NULL;
                line = g_strstrip(line);

                if (g_str_equal(line, "")) {
                        goto clean;
                }
                if (!(c = memchr(line, '=', size))) {
                        goto clean;
                }
                val = c+1;
                line[(c-line)] = '\0';

                line = g_strstrip(line);
                val = g_strstrip(val);

                if (g_str_equal(line, "vendor")) {
                        kvendor = g_strdup(val);
                } else if (g_str_equal(line, "product")) {
                        kproduct = g_strdup(val);
                }

clean:
                g_free(line);
        }

        if (kvendor && kproduct && product && vendor) {
                *vendor = kvendor;
                *product = kproduct;
                return true;
        }

        if (kvendor) {
                g_free(kvendor);
        }
        if (kproduct) {
                g_free(kproduct);
        }
        return false;
}
