/*
 * This file is part of cve-check-tool
 *
 * Copyright Â© 2015-2016 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * As an additional permission, the right to link to OpenSSL is granted.
 */

#define _GNU_SOURCE

#include <libxml/SAX2.h>
#include <libxml/parser.h>
#include <libxml/parserInternals.h>
#include <malloc.h>
#include <nica.h>
#include <stdbool.h>

#include "macros.h"
#include "nvd.h"
#include "util.h"

typedef enum {
        NVD_STATE_LIST = 1 << 1,      /**< vuln configuration */
        NVD_STATE_ENTRY = 1 << 2,     /**< Item root, basically. */
        NVD_STATE_PRODUCT = 1 << 3,   /**< CPE ident */
        NVD_STATE_SUMMARY = 1 << 4,   /**< CVE Summary */
        NVD_STATE_REFERENCE = 1 << 5, /**< Reference block */
        NVD_STATE_CVSS = 1 << 6,      /**< CVSS block */
        NVD_STATE_METRICS = 1 << 7,   /**< Metrics block */
        NVD_STATE_SCORE = 1 << 8,     /**< CVSS Score */
        NVD_STATE_VECTOR = 1 << 9,    /**< Actual vector */
        NVD_STATE_DATE = 1 << 10,     /**< Last modified date */
} NvdTraverseState;

/**
 * Convenience definition to help access the cvss parts of the document
 */
#define CVSS_BLOCK (NVD_STATE_ENTRY | NVD_STATE_CVSS | NVD_STATE_METRICS)

/**
 * Pairs a tag with a given bit field
 */
typedef struct NvdStateElement {
        const char *tag;       /**< XML Tag associated */
        NvdTraverseState flag; /**< Bitmask to set */
} NvdStateElement;

/**
 * Table of understood key -> mask mappings
 */
static const NvdStateElement elem_table[] = { { "vuln:vulnerable-software-list", NVD_STATE_LIST },
                                              { "vuln:product", NVD_STATE_PRODUCT },
                                              { "vuln:summary", NVD_STATE_SUMMARY },
                                              { "vuln:reference", NVD_STATE_REFERENCE },
                                              { "vuln:cvss", NVD_STATE_CVSS },
                                              { "cvss:base_metrics", NVD_STATE_METRICS },
                                              { "cvss:score", NVD_STATE_SCORE },
                                              { "cvss:access-vector", NVD_STATE_VECTOR },
                                              { "vuln:last-modified-datetime", NVD_STATE_DATE },
                                              { 0 } };

typedef struct NvdSaxParser {
        unsigned int nstate; /**< Current state of the parser */

        xmlChar *cur_id;      /**< CVE ID currently */
        xmlChar *summary;     /**< Current tracked summary */
        xmlChar *score;       /**< Current tracked CVSS score */
        xmlChar *vector;      /**< Current tracked CVSS vector */
        int64_t modified;     /**< Current tracked last-modified date */
        NvdCallback callback; /**< Callback to populate with products */
        NcList *products;     /**< Current set of products for current CVE */
} NvdSaxParser;

/**
 * Ensure XML is properly initialised
 */
__attribute__((constructor)) static void _nvd_init_(void)
{
        LIBXML_TEST_VERSION
}

__attribute__((destructor)) static void _nvd_destroy(void)
{
        xmlCleanupParser();
}

static void nvd_sax_handle_flip_states(NvdSaxParser *self, const xmlChar *name)
{
        for (size_t i = 0; i < ARRAY_SIZE(elem_table); i++) {
                if (!elem_table[i].tag) {
                        continue;
                }
                if (!xmlStrEqual(name, BAD_CAST(elem_table[i].tag))) {
                        continue;
                }
                self->nstate ^= elem_table[i].flag;
                return;
        }
}

static void nvd_sax_start_element(void *udata, const xmlChar *name, const xmlChar **attrs)
{
        NvdSaxParser *self = udata;

        if (xmlStrEqual(name, BAD_CAST "entry")) {
                self->nstate ^= NVD_STATE_ENTRY;
                if (attrs && attrs[0]) {
                        if (xmlStrEqual(attrs[0], BAD_CAST "id")) {
                                self->cur_id = xmlStrdup(attrs[1]);
                                fprintf(stderr, "CVE: %s\n", self->cur_id);
                        }
                }
                return;
        }

        if ((self->nstate & NVD_STATE_ENTRY) == 0) {
                return;
        }

        nvd_sax_handle_flip_states(self, name);
}

static void nvd_sax_clean(NvdSaxParser *self)
{
        xmlFree(self->cur_id);
        self->cur_id = NULL;
        xmlFree(self->summary);
        self->summary = NULL;
        xmlFree(self->vector);
        self->vector = NULL;
        xmlFree(self->score);
        self->score = NULL;
        self->modified = -1;
        nc_list_free_all(&self->products);
        self->products = NULL;
}

static void nvd_sax_end_element(void *udata, const xmlChar *name)
{
        NvdSaxParser *self = udata;
        if (xmlStrEqual(name, BAD_CAST "entry")) {
                self->nstate ^= NVD_STATE_ENTRY;
                if (!self->callback) {
                        goto next;
                }
                CveProductEntry ent = { 0 };
                ent.cve_id = (const xmlChar *)self->cur_id;
                ent.summary = self->summary;
                ent.vector = self->vector;
                ent.score = self->score;
                ent.products = self->products;
                ent.modified = self->modified;

                /* Proxy back to caller to store or validate */
                self->callback(&ent);
        next:
                nvd_sax_clean(self);
                return;
        }
        if ((self->nstate & NVD_STATE_ENTRY) == 0) {
                return;
        }
        nvd_sax_handle_flip_states(self, name);
}

static void nvd_sax_characters(void *udata, const xmlChar *ch, int len)
{
        NvdSaxParser *self = udata;

        /* Handle growing summary */
        if (self->nstate == (NVD_STATE_ENTRY | NVD_STATE_SUMMARY)) {
                xmlChar *summary = xmlStrndup(ch, len);
                /* Handle multi-line */
                if (self->summary) {
                        char *new = NULL;
                        if (!asprintf(&new, "%s%s", self->summary, summary)) {
                                abort();
                        }
                        free(self->summary);
                        free(summary);
                        self->summary = (xmlChar *)new;
                } else {
                        self->summary = summary;
                }
                return;
        }
        /* Access vector */
        if (self->nstate == (CVSS_BLOCK | NVD_STATE_VECTOR)) {
                self->vector = xmlStrndup(ch, len);
                return;
        }
        /* Score of the vuln */
        if (self->nstate == (CVSS_BLOCK | NVD_STATE_SCORE)) {
                self->score = xmlStrndup(ch, len);
                return;
        }
        /* Last modified */
        if (self->nstate == (NVD_STATE_ENTRY | NVD_STATE_DATE)) {
                xmlChar *tmp = xmlStrndup(ch, len);
                self->modified = parse_iso8601_date((const char *)tmp);
                xmlFree(tmp);
                return;
        }
        /* Product name */
        if (self->nstate == (NVD_STATE_ENTRY | NVD_STATE_LIST | NVD_STATE_PRODUCT)) {
                /* Garbage */
                if (len < 9) {
                        return;
                }

                /* Not a full version field */
                if (ch[7] != ':' && xmlStrncmp(ch, BAD_CAST "cpe:/", 5) != 0) {
                        return;
                }
                /* Return the rest of the interesting stuff, save mallocs */
                nc_list_append(&self->products, xmlStrndup(ch + 7, len - 7));
        }
}

/**
 * Parse an NVD xml database using SAX2 API
 *
 * @param fname Path to the nvd db
 * @return a boolean value, true if the operation succeeded
 */
bool nvd_sax_parser_load(const char *fname, NvdCallback callback)
{
        xmlParserCtxtPtr ctx = NULL;
        xmlSAXHandler handler = { 0 };
        NvdSaxParser instance = { 0 };
        xmlDocPtr p = NULL;
        xmlSAXHandler *old = NULL;
        handler.startElement = nvd_sax_start_element;
        handler.endElement = nvd_sax_end_element;
        handler.characters = nvd_sax_characters;
        ctx = xmlCreateFileParserCtxt(fname);
        if (!ctx) {
                fprintf(stderr, "nvd: Error creating XML context\n");
                return false;
        }
        old = ctx->sax;
        ctx->sax = &handler;
        ctx->userData = &instance;

        instance.callback = callback;

        xmlParseDocument(ctx);
        nvd_sax_clean(&instance);
        p = ctx->myDoc;
        bool good = ctx->wellFormed;
        ctx->sax = old;
        xmlFreeParserCtxt(ctx);
        if (p) {
                xmlFreeDoc(p);
        }
        xmlCleanupParser();
        malloc_trim(0);

        if (!good) {
                fprintf(stderr, "nvd: Badly formed XML file, aborting\n");
        }
        return good;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
